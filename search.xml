<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[搭建hexo博客]]></title>
    <url>%2F2019%2F04%2F29%2F%E6%90%AD%E5%BB%BAHEXO%2F</url>
    <content type="text"><![CDATA[一、配置环境1.安装Node：用来生成静态页面；2.安装Git：把本地的hexo内容提交到github上去;3.申请GitHub：是用来做博客的远程创库、域名、服务器之类的;二、安装hexo1.创建一个文件夹,npm install -g hexo2.初始化:hexo init 初始化后的生成文件说明： (1)config.yml：全局的配置文件，每次更改要重启服务。 (2)public：生成的静态文件，这个目录最终会发布到服务器。 (3)scaffolds：通用的markdown模板，Hexo有三种默认布局： post 、 page 和 draft ，它们分别对应不同的路径。新建文件的默认布局是 post。 (4)themes：默认的皮肤文件夹，主题存放于该文件夹中。 (5)source：资源文件夹是存放用户资源的地方。编写的markdown文件会存放于此，_drafts草稿文件，_posts发布的文章。3.修改配置文件4.主题安装 (1)安装主题：git clone+主题地址 (2)启用主题：打开_config.yml文件找到theme字段将其值更改为主题名 (3)修改配置文件，启用主题5.运行 (1)清除缓存：hexo clean (2)生成静态页面：hexo generate （hexo g ） (3)预览调试：hexo server（hexo s）6.部署 (1)创建GitHub仓库； (2)安装部署工具：npm install hexo-deployer-git –save； (3)修改_config.yml文件； (4)部署网站：hexo d。7.访问线上网站 http://仓库名]]></content>
      <categories>
        <category>article</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs的理解(一)]]></title>
    <url>%2F2019%2F04%2F29%2Fnodejs%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[一、Nodejs的理解：nodejs的理解:nodejs是一个平台，是服务器端js的解析器，具有速度和高性能好的优点。Nodejs本身运行v8 JavaScript。JavaScript引擎是Google用于其浏览器的底层JavaScript引擎，并且是单线程，非阻塞的应用程序，具有事件驱动、异步编程、简单易学的特点。二、什么是 error-first callback ？error-first callback 用来传递错误和数据。第一个参数永远是一个错误对象（error-object），回调函数必须检查它。余下的参数用来传递数据。三、如何避免回调函数嵌套？模块化：将回调写成单独的函数或使用?Promises四、node如何监听端口？不应该直接使用Node监听80端口（在*nix系统中），这样做需要root权限，但可以监听1024以下的端口。五、什么是事件循环？Node.js 是单进程单线程应用程序，单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数。六、Promise和async/await的区别Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch。resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。1.简洁2.错误处理：Async/Await让try/catch可以同时处理同步和异步错误。在下面的promise示例中，try/catch不能处理JSON.parse的错误，因为它在Promise中。我们需要使用.catch，这样错误处理代码非常冗余3.条件语句：promise会嵌套很多才去最后一层的promise，过于冗余。4.错误栈：Promise链中返回的错误栈没有给出错误发生位置的线索。更糟糕的是，它会误导我们；错误栈中唯一的函数名为callAPromise，然而它和错误没有关系。5.调试七、MongoDB和MySQL的区别MySQL与MongoDB都是开源的常用数据库，但是MySQL是传统的关系型数据库，MongoDB则是非关系型数据库，也叫文档型数据库。备注：分布式系统（distributed system）是建立在网络之上的软件系统]]></content>
      <categories>
        <category>article</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql的知识点]]></title>
    <url>%2F2019%2F04%2F29%2Fmysql%2F</url>
    <content type="text"><![CDATA[一、无数据则插入，有数据则更新INSERT INTO 表名 （列1，列2，列3）VALUES（？，？，？） ON DUPLICATE KEY UPDATE 列1 = ?,列2 = ?,列3 = ?；二、GROUP_CONCAT拼接SELECT keyid,GROUP_CONCAT(DISTINCT(qcResults)) AS qcResults FROMlog_api_emos_qc WHERE 1=1 GROUP BY keyid ORDER BY keyid；]]></content>
      <categories>
        <category>article</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂合知识]]></title>
    <url>%2F2019%2F04%2F29%2F%E6%9D%82%E5%90%88%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1.isnull,ifnull,nullif：（1）isnull(expr) 的用法：如expr 为null，那么isnull() 的返回值为 1，否则返回值为 0。（2）IFNULL(expr1,expr2)的用法：假如expr1 不为 NULL，则 IFNULL() 的返回值为 expr1;否则其返回值为 expr2。IFNULL()的返回值是数字或是字符串，具体情况取决于其所使用的语境。（3）NULLIF(expr1,expr2) 的用法：如果expr1=expr2 成立，那么返回值为NULL，否则返回值为expr1。2.padStart()方法,padEnd()方法如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。3.Reflect（1）将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。（2）修改某些Object方法的返回结果，让其变得更合理。（3）让Object操作都变成函数行为。（4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。（5）静态方法：Reflect.get(target, name, receiver):方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。如果name属性部署了读取函数（getter），则读取函数的this绑定receiver。如果第一个参数不是对象，Reflect.get方法会报错。Reflect.set(target, name, value, receiver):设置target对象的name属性等于value。如果name属性设置了赋值函数，则赋值函数的this绑定receiver。如果 Proxy 对象和 Reflect 对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了receiver，那么Reflect.set会触发Proxy.defineProperty拦截。如果第一个参数不是对象，Reflect.set会报错。Reflect.has(target, name)：对应name in obj里面的in运算符，如果第一个参数不是对象，Reflect.has和in运算符都会报错。Reflect.deleteProperty(target, name)：方法等同于delete obj[name]，用于删除对象的属性。该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回true；删除失败，被删除的属性依然存在，返回false。target删除属性的目标对象。propertyKey将被删除的属性的名称。Reflect.apply(target, thisArg, args)：等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。Reflect.construct(target, args)：等同于new target(…args)，这提供了一种不使用new，来调用构造函数的方法。Reflect.defineProperty(target, name, desc)：用来为对象定义属性。可以与Proxy.defineProperty配合使用。Reflect.ownKeys(target)：用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。Reflect.isExtensible(target):返回一个布尔值，表示当前对象是否可扩展。Reflect.preventExtensions(target):用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。Reflect.getOwnPropertyDescriptor(target, name):用于得到指定属性的描述对象，Reflect.getPrototypeOf(target):方法用于读取对象的proto属性,如果参数不是对象，则该方法会报错。Reflect.setPrototypeOf(target, prototype):用于设置目标对象的原型（prototype），返回一个布尔值，表示是否设置成功返回一个布尔值，表示是否设置成功。如果无法设置目标对象的原型（比如，目标对象禁止扩展），Reflect.setPrototypeOf方法返回false。如果参数不是对象或第一个参数是undefined或null，则该方法会报错。 4.push()可向数组的末尾添加一个或多个元素，并返回新的长度。5.mid()可以使用它从字符串返回指定数量的字符。6.substring()Substring(x):是从字符串的的第x个字符截取；Substring(x,y):是从x到y前的位置停止。7.json.stringfy(),json.parse()json.stringfy()将对象、数组转换成字符串；json.parse()将字符串转成json对象。8. 9..serializeJSON()调用 .serializeJSON() 方法来序列化form表单的数据成JS对象。10..parent()获得当前匹配元素集合中每个元素的父元素，使用选择器进行筛选是可选的11.$(document).ready()$(document).ready()里的代码是在页面内容都加载完才执行的，如果把代码直接写到script标签里，当页面加载完这个script标签就会执行里边的代码了，此时如果标签里执行的代码调用了当前还没加载过来的代码或者dom，那么就会报错，当然如果把script标签放到页面最后面那么就没问题了，此时和ready效果一样。$(document).ready(function(){})可以简写成$(function(){});12.$( “#” ).tabs({})把 ‘easyui-tabs’ class 添加到 标记点击标签页，切换被划分为不同逻辑部分的内容。（1）点击选中的标签页来切换内容的关闭/打开状态。为了启用这个功能，需要设置 collapsible 选项为 true。（2）在标签页链接中设置 href 的值来为标签页通过 Ajax 获取外部的内容。当 Ajax 请求在等待响应时，标签页的标签变为 “Loading…”，当加载完成后返回常规的标签。（3）通过 event 选项设置当鼠标悬停时切换各部分的打开/关闭状态。event 的默认值是 “click”。拖拽上面的标签页来对它们进行重新排序。只需要简单地调用 .ui-tabs-nav 元素上的 .sortable()，即可让标签页可排序。（4）通过一些额外的 CSS（用于定位的）和 JS（在元素上放置正确的 class），标签页皆可放置在内容的底部。（5）点击标签页，切换被划分为不同逻辑部分的内容。 13..prop(“disabled”,false)：.prop是设置对象的属性。disabled的属性为false，就是设置为可用可编辑的意思 14.node.js(1)req.query ： 处理 get 请求，获取 get 请求参数;(2)req.params ： 处理 /:xxx 形式的 get 或 post 请求，获取请求参数(3)req.body ： 处理 post 请求，获取 post 请求体(4)req.param() ： 处理 get 和 post 请求，但查找优先级由高到低为 req.params→req.body→req.query（已弃用）15.]]></content>
      <categories>
        <category>article</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs的知识点(二)]]></title>
    <url>%2F2019%2F04%2F29%2Fnodejs%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[一．NPM介绍：1.npm是NodeJS一起安装的包管理工具，常见的使用场景有三个，下载别人的包使用，下载别人的代码程序使用，上传自己的包或命令行供人家使用。2.Express安装在工程项目之下，调用方法：var express = require(‘express’);3.Pacakage.json位于模块的目录之下，属于express包的文件，常用的属性说明如下：（1）name - 包名；（2）version - 包的版本号；（3）description - 包的描述；（4）homepage - 包的官网 url；（5）author - 包的作者姓名；（6）contributors - 包的其他贡献者姓名；（7）dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下；（8）repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上；（9）main - main 字段指定了程序的主入口文件，require(‘moduleName’) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js；（10）keywords - 关键字二．回调函数（一）fs模块为nodejs的核心模块之一，主要处理文件的读写、复制、s删除、重命名等操作。当需要使用该模块时，需要先导入该文件：var fs = require(‘fs’);（二）Fs常见的属性：（1）fs.read(fd,buffer,offset,length,position,callback)：其功能为从指定的文件描述符 fd 中读取数据并写入 buffer 指向的缓冲区对象。（2）fs.write(fd,buffer,offset,length[,position],callback)：功能为将buffer内容写入fd中。（3）fs.readFile(file[,option],callback)：读取文件，同步读取（4）fs.writeFile(file,data[,options],callback)：写入文件（5）fs.createReadStream(path[,options])：以流的形式读取文件（6）fs.createWriteStream(path[,options])：以流的形式写入文件（7）fs.stat(path,callback)：该方法用于查询文件信息，其回调函数有两个参数（err, stats）。stats是一个fs.Stats对象，该对象中包含一个stats.isFile()方法。如果stats对象存在且stats.isFile()为true，才能确认要修改或删除的文件存在（8）fs.access(path[,mode],callback)：该方法用于检查到指定path路径的目录或文件的访问权限（9）fs.watch(filename [,options] [,listener])：可以监测文件的变动情况（10）fs.watchFile(file[,options],listener) ：监听filename的变化，当该文件发生变化时，执行回调函数（11）异步读取：fs.readFileSync( url , code );三．事件循环（一）Events模块是Node对“发布/订阅”模式（publish/subscribe）的实现。一个对象通过这个模块，向另一个对象传递消息：var events = require(‘events’)；（1）通过实例化 EventEmitter 类来绑定和监听事件:var eventEmitter = new.EventEmitter ();（2）on方法用来监听事件(绑定),emit用来发出事件(触发)；（二）EvenEmmiter:是events的对象，主要用于事件监听和事件触发的功能。（1）evevemmiter的属性介绍：① addListener(event, listener)：为指定事件添加一个监听器到监听数组的尾部。② on(event, listener)：注册一个监听器，接受一个字符串event和一个回调函数。③ once(event, listener)：添加一个单次监听器，监听一次之后触发之后立刻解除该监听器。④ removeListener(event, listener)：移除某个已经注册过的监听器。⑤ removeAllListeners([event])：移除所有事件或某个事件的所有监听器。⑥ setMaxListeners(n)：用于提高监听器的数量（默认数量为10）。⑦ listeners(event)：返回监听数组。⑧ emit(event, [arg1], [arg2], […])：按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。⑨ listenerCount(emitter, event)：返回监听器的数量。⑩ newListener：event - 字符串，事件名称，listener - 处理事件函数。该事件在添加新监听器时被触发。⑪ removeListener：从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。（三）大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。四．Buffer：JavaScript 语言自身只有字符串数据类型，没有二进制数据类型，所以定义了一个buffer类用来存放二进制的缓存区。（一）写入缓存区：buf.write(string[, offset[, length]][, encoding])，string - 写入缓冲区的字符串,offset - 缓冲区开始写入的索引值，默认为 0 ,length - 写入的字节数，默认为 buffer.length,encoding - 使用的编码，默认为 ‘utf8’ 。（二）读取数据：buf.toString([encoding[, start[, end]]])。（三）将buffer转为json对象：buf.toJSON()，当字符串化一个 Buffer 实例时，JSON.stringify() 会隐式地调用该 toJSON()。（四）缓冲区合并：Buffer.concat(list[, totalLength]，list - 用于合并的 Buffer 对象数组列表，totalLength - 指定合并后Buffer对象的总长度。（五）缓冲区比较：buf.compare(otherBuffer)。（六）拷贝缓冲区：buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])。（七）缓冲区剪裁：buf.slice([start[, end]])。（八）缓冲区长度：buf.length。五．Stream（流）：是一个抽象接口（一）var zlib = require (‘zlib’); 它提供了Gzip/Gunzip,Deflate/Inflate和DeflateRaw/InflateRaw类的绑定。（二）.pipe():管道流五、模块系统:为了让NodeJS文件能够相互调用（一）Export是模块的公开接口（二）Require用于从外部获取模块的公开接口六．路由：根据不同的url地址有不同的处理方式：let router = express.router（）七．全局变量：（一）（1）filename：当前正在执行的脚步的文件名（输出绝对路径）（2）dirname:当前脚步所在的目录（3）setTimeout(cb, ms)：全局函数在指定毫秒内执行指定函数(cb),只执行一次（4）clearTimeout( t ) ：用于停止一个之前通过 setTimeout() 创建的定时器。 参数 t 是通过 setTimeout() 函数创建的定时器。（5）setInterval(cb, ms) ：全局函数在指定的毫秒(ms)数后执行指定函数(cb)。它会一直调用函数，直到clearTimeout( t )被调用或窗口关闭（二）console：（1）console.log([data][, …])；向标准输出流打印字符并以换行符结束。（2）console.info([data][, …])：返回信息性消息。（3）console.error([data][, …])：输出错误消息的。（4）console.warn([data][, …])：输出警告消息。（5）console.dir(obj[, options])：用来对一个对象进行检查，以易于阅读和打印的格式显示。（6）console.time(label)；输出时间，表示计时开始。（7）console.timeEnd(label)：结束时间，表示计时结束。（8）console.trace(message[, …])：当前执行的代码在堆栈中的调用路径。（9）console.assert(value[, message][, …])；用于判断某个表达式或变量是否为真，接收两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果（三）Process：它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。八．常用的工具：（一）util.inherits(constructor, superConstructor)是一个实现对象间原型继承 的函数（二）util.inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象（三）Util.Array(object):如果给定的参数 “object” 是一个数组返回true，否则返回false（四）Util.isRegExp(object):如果给定的参数 “object” 是一个正则表达式返回true，否则返回false（五）Util.Data(object):如果给定的参数 “object” 是一个日期返回true，否则返回false（六）Util.isError(object):给定的参数是一个错误对象，那就返回true,否则返回false九．文件系统：导入文件系统模块的语法： let fs = require.(‘fs’)(一)fs.readFile:异步读取(二)fs.readFileSync;同步读取(三)fs.open(path,flags[,mode],callback):打开文件path - 文件的路径。flags - 文件打开的行为： r：以读取模式打开文件。如果文件不存在抛出异常。 r+:以读写模式打开文件。如果文件不存在抛出异常。 rs:以同步的方式读取文件。 rs+:以同步的方式读取和写入文件 w:以写入模式打开文件，如果文件不存在则创建。 wx：类似 ‘w’，但是如果文件路径存在，则文件写入失败。 w+：以读写模式打开文件，如果文件不存在则创建。 wx+:类似 ‘w+’， 但是如果文件路径存在，则文件读写失败。 a：以追加模式打开文件，如果文件不存在则创建。 ax：类似 ‘a’， 但是如果文件路径存在，则文件追加失败。 a+：以读取追加模式打开文件，如果文件不存在则创建。 ax+：类似 ‘a+’， 但是如果文件路径存在，则文件读取追加失败。mode - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。callback - 回调函数，带有两个参数如：callback(err, fd)。(四)fs.stat(path,callback):通过异步获取文件信息（1）stats.isFile()：如果是文件返回true；（2）stats.isDirectory()：如果是目录返回true；（3）stats.isBlockDevice()：如果是块设备返回true；（4）stats.isCharacterDevice()：如果是字符设备返回true；（5）stats.isSymbolicLink()：如果是软链接返回true；（6）stats.isFIFO()：如果是FIFO，返回true，否则返回 false。FIFO是UNIX中的一种特殊类型的命令管道。（7）stats.isSocket()：如果是 Socket 返回 true，否则返回 false。(五)fs.writeFile(file, data[, options], callback):写入文件(六)fs.read(fd, buffer, offset, length, position, callback)：fd - 通过 fs.open() 方法返回的文件描述符。buffer - 数据写入的缓冲区。offset - 缓冲区写入的写入偏移量。length - 要从文件中读取的字节数。position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。callback - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。(七)fs.close(fd, callback)：关闭文件(八)fs.ftruncate(fd, len, callback)：截取文件(九)fs.unlink(path, callback)：删除文件(十)fs.mkdir(path[, mode], callback)：创建目录(十一)fs.readdir(path, callback)：读取目录(十二)fs.rmdir(path, callback)：删除目录十、get/post请求（一）get：可以用util.parse来解析url里的参数十一、工具模块（一）var os = require(“os”)：os 模块提供了一些基本的系统操作函数。（二）var path = require(“path”)：提供了一些处理文件路劲的小工具。（三）var net = require(“net”):用于底层的网络通信（1）net.Server通常用于创建一个 TCP 或本地服务器。（2）Net.socket对象是 TCP 或 UNIX Socket 的抽象。net.Socket 实例实现了一个双工流接口。（四）var dns = require(“dns”)：用于解析域名（五）var domain = require(“domain”)：用于捕捉try catch都无法捕捉到的异步异常。十二、express：是一个应用框架，可以快速地搭建一个完整功能的网站（一）request请求：request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有：（1）req.app：当callback为外部文件时，用req.app访问express的实例。（2）req.baseUrl：获取路由当前安装的URL路径。（3）req.body / req.cookies：获得「请求主体」/ Cookies，主要用于接收post的请求。（4）Req.fresh:用来判断req,res中的HTTP头是否依然有效。（5）req.hostname / req.ip：获取主机名和IP地址。（6）req.originalUrl：获取原始请求URL。（7）req.params：获取路由的parameters，一个数组，包含命名过的路由参数。（8）req.path：获取请求路径。（9）req.protocol：获取协议类型。（10）req.query：获取URL的查询参数串，用于接收get请求。（11）req.route：获取当前匹配的路由。（12）eq.subdomains：获取子域名。（13）req.accepts()：检查可接受的请求的文档类型。（14）eq.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages：返回指定字符集的第一个可接受字符编码。（15）req.get()：获取指定的HTTP请求头。（16）req.is()：判断请求头Content-Type的MIME类型（二）Response相应：(1)res.app：同req.app一样(2)res.append()：追加指定HTTP头(3)res.set()在res.append()后将重置之前设置的头(4)res.cookie(name，value [，option])：设置Cookie opition: domain / expires / httpOnly / maxAge / path / secure / signed(5)res.clearCookie()：清除Cookie(6)res.download()：传送指定路径的文件(7)res.get()：返回指定的HTTP头(8)res.json()：传送JSON响应(9)res.jsonp()：传送JSONP响应(10)res.location()：只设置响应的Location HTTP头，不设置状态码或者close response(11)res.redirect()：设置响应的Location HTTP头，并且设置状态码302(12)res.render(view,[locals],callback)：渲染一个view，同时向callback传递渲染后的字符串，如果在渲染过程中有错误发生next(err)将会被自动调用。callback将会被传入一个可能发生的错误以及渲染后的页面，这样就不会自动输出了。(13)res.send()：传送HTTP响应(14)res.sendFile(path [，options] [，fn])：传送指定路径的文件 -会自动根据文件extension设定Content-Type(15)res.set()：设置HTTP头，传入object可以一次设置多个头(16)res.status()：设置HTTP状态码(17)res.type()：设置Content-Type的MIME类型（三）路由决定由谁去相应请求十三、多进程：1.exec() 方法：使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。exec() 方法返回最大的缓冲区，并等待进程结束，一次性返回缓冲区的内容。2.Spawn：使用指定的命令行参数创建新进程。spawn() 方法返回流 (stdout &amp; stderr)，在进程返回大量数据时使用。进程一旦开始执行时 spawn() 就开始接收响应。3.Fork: 是 spawn() 方法的特殊形式，用于创建进程。会有一个内建通道。十四、与MySQL的连接：var mysql = require(‘mysql’);十五、与MongoDB的连接：1.创建数据库:要在 MongoDB 中创建一个数据库，首先我们需要创建一个 MongoClient 对象，然后配置好指定的 URL 和 端口号。2.创建集合：createCollection() 。3.数据库操作：与 MySQL 不同的是 MongoDB 会自动创建数据库和集合，所以使用前我们不需要手动去创建。（1）insertOne()：插入一条数据；.insertOne(key(数据), function(err, res) {})（2）insertMany()：插入多条数据；.insertMany([数据], function(err, res) {}）（3）find()：查询数据；. find({条件}).toArray(function(err, result) {}）（4）updateOne():更新一条:.updateOne(whereStr(条件), updateStr（数据updateStr={$set:{“”:“”}}）, function(err, res) {})(5)updateMany():更新多条数据：.updateMany(whereStr, updateStr, function(err, res) {}）（6）deleteOne():删除单条数据；.deleteOne(whereStr, function(err, obj) {})(7)deleteMany():删除多条：.deleteMany(whereStr, function(err, obj) {})(8)sort()；排序：{ type: 1 } // 按 type 字段升序 { type: -1 } // 按 type 字段降序（9）limit()：分页查询：.find().limit(num).toArray(function(err, result) {})(10)$lookup:左连接(11)drop():删除集合：.drop(function(err, delOK) {})十六、promise和async/await的区别（1）async更简洁，避免了嵌套代码（2）错误处理：async可以用try/catch捕获错误，但是promise只能用.catch，代码更加的冗余（3）条件语句：promise可能需要嵌套一层又一层的.then来获取值，最终只需要最外层的值，而async只需要return一次就可以，减少了代码的冗余。（4）错误栈：promise链中返回的错误栈没有给出错误发生的位置线索，错误栈中唯一的函数名为callAPromise，和错误没有关系，而async会指向错误所在的函数。十七、exports和module.exports的区别1.exports是module.exports的一个引用，exports=module.exports={}2.module.exports=xxx，相当于导出某个函数，在另一个文件中引用后可直接调用3.exports.xxx和module.exports.xxx相当于把函数或变量挂载在对象上，在另一个文件中应用后，通过调用对象属性和方法进行使用]]></content>
      <categories>
        <category>article</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的相关知识点]]></title>
    <url>%2F2019%2F04%2F29%2FGIt%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[一、git的定义：（1）git是一款免费、开源的分布式（是建立在网络之上的软件系统）版本控制系统，用于敏捷高效的处理或大或小的项目；（2）Git是一个强调速度快的源代码管理工具；（3）每一个git工作目录都是一个完全独立的代码库，并拥有完整的历史记录和版本最终能力，不依赖于网络和中心服务器。二、git的常用命令：（1）add:将文件添加到本地的Git库中，相当于svn中的add。（2）Conmmit:提交本地的git库文件到远程git库中。（3）Fetch：从服务器中拉取最新的内容到本地库中，但是不合并。（4）Pull:从服务器中拉取最新的内容到本地库中，并尝试不合并。（5）Push：将本地git库的文件推送到远程git库中，并尝试自动合并。（6）Clone：从服务器主库中获取目录及版本库到本地。（7）其他命令：类似show log(查看版本日志信息)，revert（推回pull下来的初始状态），diff]]></content>
      <categories>
        <category>article</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运行hexo]]></title>
    <url>%2F2019%2F04%2F26%2F%E8%BF%90%E8%A1%8Chexo%2F</url>
    <content type="text"><![CDATA[一、步骤 1、d: //cd到d盘 2、cd xxx //cd到当前目录 3、hexo s //运行hexo 4、hexo g //部署 5、hexo clean //清除二、常见错误 1、config.xml文件没空格 2、文章中出现大括号，无法识别。]]></content>
      <categories>
        <category>article</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js]]></title>
    <url>%2F2019%2F04%2F26%2Fvue%2F</url>
    <content type="text"><![CDATA[一、Vue.js Vue（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架； Vue 只关注视图层， 采用自底向上增量开发的设计； Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。 二、应用 每个 Vue 应用都需要通过实例化 Vue 来实现。语法格式如下： var vm = new Vue({ // 选项 }) 实例： &lt;div id=&quot;vue_det&quot;&gt; &lt;h1&gt;site : {{site}}&lt;/h1&gt; &lt;h1&gt;url : {{url}}&lt;/h1&gt; &lt;h1&gt;{{details()}}&lt;/h1&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue({ el: &apos;#vue_det&apos;,//el 参数，它是 DOM 元素中的 id data: { //data 用于定义属性，实例中有三个属性分别为：site、url、alexa。 site: &quot;菜鸟教程&quot;, url: &quot;www.runoob.com&quot;, alexa: &quot;10000&quot; }, methods: { //methods 用于定义的函数，可以通过 return 来返回函数值。 details: function() { return this.site + &quot; - 学的不仅是技术，更是梦想！&quot;; } } }) &lt;/script&gt; 除了数据属性，Vue 实例还提供了一些有用的实例属性与方法。它们都有前缀 $，以便与用户定义的属性区分开来。 三、Vue.js 模板语法 Vue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。 1、插值 （1）文本：数据绑定最常见的形式就是使用 双大括号的文本插值： Vue 测试实例 - 菜鸟教程(runoob.com) &lt;script&gt; new Vue({ el: &apos;#app&apos;, data: { message: &apos;Hello Vue.js!&apos; } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 输出结果：Hello Vue.js! （2）Html：使用 v-html 指令用于输出 html 代码： &lt;div id=&quot;app&quot;&gt; &lt;div v-html=&quot;message&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el: &apos;#app&apos;, data: { message: &apos;&lt;h1&gt;菜鸟教程&lt;/h1&gt;&apos; } }) &lt;/script&gt; 2、属性：HTML 属性中的值应使用 v-bind 指令 3、指令：指令是带有 v- 前缀的特殊属性。 4、参数：参数在指令后以冒号指明。 5、修饰符：修饰符是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。 .prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()： &lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt; 6、用户输入：在 input 输入框中我们可以使用 v-model 指令来实现双向数据绑定： &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{ message }}&lt;/p&gt; &lt;input v-model=&quot;message&quot;&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el: &apos;#app&apos;, data: { message: &apos;Runoob!&apos; } }) &lt;/script&gt; v-model 指令用来在 input、select、text、checkbox、radio 等表单控件元素上创建双向数据绑定，根据表单上的值，自动更新绑定的元素的值。 按钮的事件我们可以使用 v-on 监听事件，并对用户的输入进行响应。 7、过滤器：Vue.js 允许你自定义过滤器，被用作一些常见的文本格式化。 四、Vue.js 条件与循环 1、v-if 2、v-else:可以用 v-else 指令给 v-if 添加一个 &quot;else&quot; 块 3、v-else-if:用作 v-if 的 else-if 块。可以链式的多次使用 4、v-show:根据条件展示元素 五、循环指令 1、v-for 指令需要以 site in sites 形式的特殊语法， sites 是源数据数组并且 site 是数组元素迭代的别名。 2、v-for 迭代对象：v-for 可以通过一个对象的属性来迭代数据 &lt;li v-for=&quot;value in object&quot;&gt; {{ value }} &lt;/li&gt; 你也可以提供第二个的参数为键名： &lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(value, key) in object&quot;&gt; {{ key }} : {{ value }} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 第三个参数为索引： &lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(value, key, index) in object&quot;&gt; {{ index }}. {{ key }} : {{ value }} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 3、v-for 迭代整数 &lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;n in 10&quot;&gt; {{ n }} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 六、Vue.js 监听属性 1、通过 watch 来响应数据的变化 实例： &lt;div id = &quot;app&quot;&gt; &lt;p style = &quot;font-size:25px;&quot;&gt;计数器: {{ counter }}&lt;/p&gt; &lt;button @click = &quot;counter++&quot; style = &quot;font-size:25px;&quot;&gt;点我&lt;/button&gt; &lt;/div&gt; &lt;script type = &quot;text/javascript&quot;&gt; var vm = new Vue({ el: &apos;#app&apos;, data: { counter: 1 } }); vm.$watch(&apos;counter&apos;, function(nval, oval) { alert(&apos;计数器值的变化 :&apos; + oval + &apos; 变为 &apos; + nval + &apos;!&apos;); }); &lt;/script&gt;]]></content>
      <categories>
        <category>article</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PS教程]]></title>
    <url>%2F2019%2F04%2F26%2FPS%2F</url>
    <content type="text"><![CDATA[一、手绘 ctrl+alt+shift+E:盖印图层 1、皮肤磨皮： ctrl + j:复制图层，滤镜 &gt; 模糊 &gt; 高斯模糊 &gt; 2.5 , 添加矢量蒙版 + alt ,盖印 画笔脸部 &gt; 窗口 &gt; 路径， 画笔脖子 &gt; 窗口 &gt; 路径]]></content>
      <categories>
        <category>article</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB之Schema与Model]]></title>
    <url>%2F2019%2F04%2F26%2Fmongodb-schema-model%2F</url>
    <content type="text"><![CDATA[一、Schema 是什么 在 Mongoose 中，所有数据都由一个 Schema 开始创建。每一个 schema 都映射到一个 Mongodb 的集合(collection)，并定义了该集合(collection)中的文档(document)的形式。 例子：定义一个Scheme const mongoose = require(‘mongoose’); const Schema = mongoose.Schema; const UserScehma = new Schema({ name: { type: String, required: true },//name 称之为Schema 的键,每一个键都定义了一个文档(document)的一个属性。 createTime: { type: Date, default: Date.now }, favoriteIds: [String] sex: String, avatar: String, vip: Boolean, }) 二、实例方法 通过Schema 创建Model 构造出的实例； 例子：可以为Model 创建实例方法供Model 实例调用。 const animalSchema = new Schema({ name: String, type: String }) // 实例方法 animalSchema.methods.findSimilarTypes = async function() { // this 为调用此方法的Model 实例对象，此实例使用Model 方法前还需要指定model return this.model(‘Animal’).findOne({ type: this.type }) } const Animal = mongoose.model(‘Animal’, animalSchema) const dog = new Animal({ type: ‘dog’ }) dog.findSimilarTypes().then(animal =&gt; console.log(animal.name)) // woff 三、静态方法 通过Schema 创建的Model 例子：我们可以为Model 创建静态方法供Model 调用 const animalSchema = new Schema({ name: String, type: String }) // 静态方法 animalSchema.statics.findByName = async function(name) { return this.findOne({ name }) } const Animal = mongoose.model(&apos;Animal&apos;, animalSchema) Animal.findByName(&apos;tom&apos;).then(animal =&gt; console.log(animal.name)) // tom 四、collection和read详解： var workOrderOptSchema = new Schema( name: { type: String, required: true }, {collection: “work_order_info_opt”,read: ‘secondaryPreferred’}//mongodb集合名 ); collection：匹配mongodb集合名； read目前支持的模式： 1）primary：读操作只发生在primary上，默认的read模式。如果primary失效，则返回error。 2）primaryPreferred：读操作发生在primary上，如果primary失效，则由secondary接收read请求。这是一种比较良好的模式。 3）secondary：读操作只发生在secondary上，如果所有的secondary都失效，则返回error。 4）secondaryPreferred：读操作通常发生在secondary上，如果所有的secondary都失效，则由primary接收read请求。 5）nearest：读取“最近”的节点，mongodb客户端将评估与每个节点的网络延迟，有限选择延迟最小的节点， primary和secondary都有可能接收到read请求（不同的Client或许延迟不同）。 五、Mongodb操作与基本特性 (一)、BSON Mongodb中数据存储格式为BSON，和JSON非常类似，可以说在整体的结构几乎一样，只不过BSON定义了更多的数据类型，这对面向对象编程语言非常友好。 (二)、Read操作 即从mongodb中读取一条或者多条数据，可以在query中使用多种复合查询条件，这种查询条件的组合类似于SQL， 我们也可以使用“projection”过滤器来指定需要返回的结果中包含（不包含）哪些字段。 1、比较符 mongodb支持如下几种比较操作，它们均可以在query的查询条件中：$eq（相等，逐字节比较），$gt（大于），$gte（大于等于）， $lt（小于），$lte（小于等于），$ne（不等于），$in（值是否在指定的数组中），$nin（值不在制定的数组中）。 2、逻辑判断符 $or：逻辑or，如果document匹配多个条件判断中的一个或者多个，则将此document返回。 $and：逻辑and，document必须匹配全部的判断条件。 $not：逻辑!，$and取反，如果document不匹配条件，则返回此document。比如：&quot;age&quot;:{$not:{$gt:16}}表示“获取age不大于16的document”， 它的内部检测过程就是“如果此document存在age字段，且大于16的，一律不返回”，言外之意是：如果document中不包含age字段，或者age的值小于等于16的均会返回。 $nor：not or。 3、元素 $exists：检测文档中是否存在此字段，比如: &quot;name&quot;:{$exists:true}表示如果name字段存在，则返回此文档。 $type：检测文档中字段的类型，比如：&quot;age&quot;:{$type:16}表示如果age字段的类型为int则返回此文档 4、数组 $all：如果字段的值是数组，$all表示此数组中包含指（不一定必须等于）定的所有元素。比如：&quot;addresses&quot;:{$all:[&quot;beijing&quot;,&quot;shanghai&quot;]}， 首先addresses字段值是一个数组，且同时包含“beijing”、“shanghai”两个元素。 $elemMatch：数组中至少包含一个元素同时满足条件，比如：&quot;item&quot;:{$elemMatch:{$gt:25,$lt:60}}，这表示数组item至少包含一个元素大于25且小于60， item:[15,26,70]这个文档就符合要求，而item:[16,62]就不符合要求。 $size：数组的元素个数满足条件，比如&quot;item&quot;:{$size:2}则会返回item中元素个数为2的文档。 此外，我们可以在表达式中指定index位置来获取数组中的元素：collection.find(new Document(&quot;addresses.0&quot;,&quot;beijing&quot;)) //表示获取addresses这个数组中第0个位置的元素值为“beijing”的文档。 5、运算与表达式 $mod：取模运算，比如&quot;price&quot;:{$mod:[4,0]}即获取price与4取模为0的文档。 $regex：正则匹配，基于PCRE，首先参与匹配的field必须建立索引，否则性能受限。 6、projection $：这个符号，很特殊，对于query而言，用于获数组中匹配比较表达的第一个元素。 projection是mongodb提供了用于过滤返回字段的操作，1表示包含字段，0表示不包含。 $slice：限定返回结果中数组元素的数量，可以只返回数据的起止位置之间的元素。 7、find()方法：返回一个FindIterable对象，我们通常根据FindIterable获取一个Cursor，我们就可以遍历此cursor，依次读取结果集，FindIterable中有很多方法有用的方法： 1）batchSize(int size)：每次网络请求返回的document条数，比如你需要查询500条数据，mongodb不会一次性全部load并返回给client，而是每次返回batchSize条， 遍历完之后后再通过网路IO获取直到cursor耗尽。默认情况下，首次批量获取101个document或者1M的数据，此后每次4M，当然我们可以通过此方法来覆盖默认值， 如果文档尺寸较小，则建议batchSize可以大一些。 2）skip(int number)、limit(int number)：同SQL中的limit字句，即表示在符合匹配规则的结果集中skip一定数量的document， 并最终返回limit条数据。可以实现分页查询。 3）maxTime(int time,TimeUnit unit)：表示此次操作保持的最长时间，即server端保持cursor状态的最长时间，如果超时server端将移除此cursor， 即在此通过此cursor遍历数据将会error。 4）sort(Bson bson)：根据指定field排序，参与排序的字段最好是索引，如果不是，将会在内存中排序，如果参与排序的数据尺寸大于32M， 将会抛出error。1表示正序，-1表示倒叙，比如&quot;age&quot;:1表示按照age正序排序。 5）noCursorTimeout(boolean timeout)：如果cursor空闲一定时间后（10分钟），server端是否将其移除，默认为false， 即server会将空闲10分钟的cursor移除以节约内存。如果为true，则表示server端不需要移除空闲的cursor，而是等待用户手动关闭。 无论如何，开发者都需要注意，手动关闭cursor。 6）partial(boolean partial)：对于sharding集群，如果一个或者多个shard不可达，是否允许返回部分数据（只从正常的shard中获取数据）。 7）cursorType()：指定cursor类型，当cursor遍历完毕后是否关闭cursor，默认是关闭，无论何时都建议手动关闭cursor（不管是否耗尽curosr）； 当然有些开发场景可能需要保持cursor的活性，遍历到cursor的最后一条后，不关闭cursor，继续等待，此后一段时间内如果有新数据插入到cursor之后， 则可以继续遍历，这就是Tailable Cursor，通常对于Capped Collection中使用。目前支持支持3种类型的Cursor：NonTailable、Tailable、TailableAwait。 8）projection(Bson bson)：限定返回结果中需要包含的filed或者数组元素。在6）中我们已经看到相关的几个例子。默认情况下， 将会返回document的所有字段，1表示包含，0表示不包含。 (三)Write操作 write操作包括insert、update，replace,remove四种类型，需要清楚的是mongodb并不支持事务，所以如果write操作影响多条document， 那么它们之间的变更并非原子性的，即有可能几条document修改（插入）成功但是其他的或许失败；对于一个document而言，是原子性的， 不可能存在一个documnet被部分更新的情况。]]></content>
      <categories>
        <category>article</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise&co/yield]]></title>
    <url>%2F2019%2F04%2F26%2Fpromise-co-yield%2F</url>
    <content type="text"><![CDATA[一、promise（一）Promise的定义：所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。（二）Promise语法与then的用法： 1、resolve(value)是在Promise在已经异步完成成功(Resolved)之后执行的 2、reject(value)是在Promise在异步失败之后(Rejected)执行。 3、只要在第一个promise回调中添加resolve，之后的连续then就会默认执行。4、可以在then中return出数据，并且这个数据会以参数的形式传入下一个then。（三）Promise语法与catch()的用法：catch是用于指定发生错误时的回调函数，catch()使回调报错时不会卡死js而是会继续往下执行 例子：var p = new Promise((resolve,reject)=&gt; { n} ).then(()=&gt;console.log(‘运行成功’)) .catch( ()=&gt;{a;console.log(‘报错’);} )//这里我们没有定义a的值会报错 .catch( ()=&gt; console.log(‘报错2’) ) .then( ()=&gt;console.log(‘报错后的回调’) )//运行结果是：’报错2’ ‘报错后的回调’ 首先n没有定义，所以第一层出错。下一个then的‘运行成功’不会被打出来。而是会被下一个catch捕获，第一个catch没有定义a，所以报错，console.log(‘报错’)没办法打出来，又被下一个catch捕获： 第二个catch没有问题：打出‘报错2’。运行成功传给下一个then，打出’报错后的回调’。 （四）Promise常用的方法 1、Promise.all()：var p = Promise.all([p1,p2,p3])all()接受数组作为参数。p1,p2,p3都是Promise的实例对象，p要变成Resolved状态需要p1，p2，p3状态都是Resolved，如果p1,p2,p3至少有一个状态是Rejected，p的状态就变成Rejected； 2、Promise.race()：var p = new Promise([p1,p2,p3])只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 3、Promise resolve():有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。 4、Promise reject()：Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数 5、想要同步的时候，就使用Promise链，想要异步，就使用Promise.all() 二、CO（一）co 模块是能让我们以同步的形式编写异步代码的 nodejs 模块 co 和 yield 同样也是解决 异步变同步的方法 举个例子：sayhello是一个异步函数：function sayhello() { return Promise.resolve(‘hello’).then(function(hello) { console.log(hello); });}function helloworld() { sayhello(); console.log(‘world’);}helloworld(); 输出结果：&gt; “world” &gt; “hello” co 的方式：function co(gen) { var it = gen(); var ret = it.next(); ret.value.then(function(res) { it.next(res); });}function sayhello() { return Promise.resolve(‘hello’).then(function(hello) { console.log(hello); });}co(function *helloworld() { yield sayhello(); console.log(‘world’);});输出结果：&gt; “hello” &gt; “world” 假设sayhello/sayworld/saybye是三个异步函数，用真正的 co 模块就可以这么写：var co = require(‘co’); co(function *() { yield sayhello(); yield sayworld(); yield saybye();});输出结果：&gt; “hello” &gt; “world” &gt; “bye” （二）要了解 co ，就不得不先简单了解下 ES6 的 generator 和 iterator。 1、iterator:iterator迭代器是一个对象，知道如何从一个集合一次取出一项，而跟踪它的当前序列所在的位置，它提供了一个next()方法返回序列中的下一个项目。 var lang = { name: &apos;JavaScript&apos;, birthYear: 1995 }; var it = Iterator(lang); var pair = it.next(); console.log(pair); // [&quot;name&quot;, &quot;JavaScript&quot;] pair = it.next(); console.log(pair); // [&quot;birthYear&quot;, 1995] pair = it.next(); // A StopIteration exception is thrown 2、Generator：Generator 生成器允许你通过写一个可以保存自己状态的的简单函数来定义一个迭代算法。Generator 是一种可以停止并在之后重新进入的函数。生成器的环境（绑定的变量）会在每次执行后被保存，下次进入时可继续使用。 function *gen() { yield ‘hello’; yield ‘world’; return true; } ar iter = gen(); var a = iter.next(); console.log(a); // {value:’hello’, done:false} var b = iter.next(); console.log(b); // {value:’world’, done:false} var c = iter.next(); console.log(c); // {value:true, done:true} 注解：当执行gen()的时候，并不执行 generator 函数体，而是返回一个迭代器。迭代器具有next()方法，每次调用 next() 方法，函数就执行到yield语句的地方。next() 方法返回一个对象，其中value属性表示 yield 关键词后面表达式的值，done 属性表示是否遍历结束。]]></content>
      <categories>
        <category>article</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql & mongoDB]]></title>
    <url>%2F2019%2F04%2F26%2Fmysql-MongoDB%2F</url>
    <content type="text"><![CDATA[一、MySQL：MySQL是一个关系型数据库管理系统。 1、所谓关系模型就是“一对一、一对多、多对多”等关系模型，关系模型就是指二维表格模型,因而一个关系型数据库就是由二维表及其之间的联系组成的一个数据组织。2、非关系型模型比如有: (1)列模型：存储的数据是一列列的。关系型数据库以一行作为一个记录，列模型数据库以一列为一个记录。比如：Hbase (2)键值对模型：存储的数据是一个个“键值对”。比如：redis,MemcacheDB (3)文档类模型：以一个个文档来存储数据，有点类似“键值对”。比如：mongoDB 二、MongoDB：MongoDB 是一个基于分布式文件存储的数据库 1、分布式文件系统（Distributed File System）是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点相连。]]></content>
      <categories>
        <category>article</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的提交]]></title>
    <url>%2F2019%2F04%2F26%2FGit%E7%9A%84%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[不创建ssh密钥的情况下的提交： 1、git init 2、git pull —rebase https://github.com/panhonger/Synthesize_games.git master 3、git add . 4、git commit -m ‘文件名’ 5、git remote add origin https://github.com/panhonger/Synthesize_games.git6、git push origin master]]></content>
      <categories>
        <category>article</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>article</tag>
      </tags>
  </entry>
</search>
